#!/usr/bin/env python3
"""
wake-pc — Wake your PC via the ESP32 Tailscale WoL bridge.

Sends UDP triggers every second until the ESP32 confirms with an ACK ("ok"),
then exits immediately. Worst-case wait: ~25 s (one full reconnect cycle).

Usage:
  wake-pc                              # uses saved default IP
  wake-pc <esp32-tailscale-ip>         # specify IP explicitly
  wake-pc --save 100.126.x.x          # save a default IP for next time
  wake-pc --timeout 30                 # custom timeout

The ESP32 Tailscale IP is shown in the serial monitor banner after boot,
and in the Tailscale admin console under the device name "esp32-wol".
"""

import os
import socket
import sys
import time
import argparse

CONFIG_DIR = os.path.join(os.path.expanduser("~"), ".config", "wake-pc")
CONFIG_FILE = os.path.join(CONFIG_DIR, "default-ip")


def load_default_ip():
    try:
        with open(CONFIG_FILE) as f:
            return f.read().strip()
    except FileNotFoundError:
        return None


def save_default_ip(ip):
    os.makedirs(CONFIG_DIR, exist_ok=True)
    with open(CONFIG_FILE, "w") as f:
        f.write(ip + "\n")
    print(f"Saved default IP: {ip}")
    print(f"  (stored in {CONFIG_FILE})")


def main():
    default_ip = load_default_ip()

    parser = argparse.ArgumentParser(
        description="Wake PC via ESP32 Tailscale WoL bridge",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
examples:
  wake-pc 100.126.x.x          # wake using this IP
  wake-pc                       # wake using saved default IP
  wake-pc --save 100.126.x.x   # save default IP for future use
        """
    )
    parser.add_argument(
        "esp32_ip", nargs="?", default=default_ip,
        help="ESP32 Tailscale VPN IP"
             + (f" (default: {default_ip})" if default_ip else " (required on first use)")
    )
    parser.add_argument(
        "--save", metavar="IP", dest="save_ip",
        help="Save a default ESP32 IP for future use"
    )
    parser.add_argument(
        "--port", type=int, default=9999,
        help="UDP listen port configured on ESP32 (default: 9999)"
    )
    parser.add_argument(
        "--timeout", type=int, default=25,
        help="Max seconds to wait for ACK (default: 25 — one full reconnect cycle)"
    )
    args = parser.parse_args()

    if args.save_ip:
        save_default_ip(args.save_ip)
        if not args.esp32_ip:
            args.esp32_ip = args.save_ip

    if not args.esp32_ip:
        parser.error(
            "ESP32 IP required. Provide it as an argument or save a default:\n"
            "  wake-pc 100.126.x.x          # one-time use\n"
            "  wake-pc --save 100.126.x.x   # save for future"
        )

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.settimeout(1.0)  # wait up to 1 s for ACK after each send

    print(f"Waking PC via ESP32 ({args.esp32_ip}:{args.port}) ...")

    deadline = time.time() + args.timeout
    attempt  = 0

    while time.time() < deadline:
        attempt += 1
        try:
            sock.sendto(b"wake", (args.esp32_ip, args.port))
        except OSError as e:
            print(f"Send error: {e}", file=sys.stderr)
            sys.exit(1)

        try:
            data, _ = sock.recvfrom(32)
            if data.strip() == b"ok":
                print(f"Done! ESP32 confirmed (attempt {attempt}).")
                sock.close()
                sys.exit(0)
        except socket.timeout:
            pass  # no ACK yet — keep sending

    # Sent for the full window — ESP32 should have received at least one trigger.
    # ACK didn't arrive (DERP path back may not be symmetric) but WoL was likely sent.
    sock.close()
    print(f"Sent {attempt} trigger(s) over {args.timeout} s.")
    print("Check your PC — it should be waking up.")
    print("(No ACK received, but that may be a DERP routing limitation.)")


if __name__ == "__main__":
    main()
